varying vec2 vUv0;

uniform sampler2D particleTexIN;
uniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;
uniform mat3 spawnBounds;
uniform mat3 emitterMatrix;
uniform float delta, rate, rateDiv, lifetime, numParticles, totalTime, totalTimePrev, rotSpeedDivMult, oneShotStartTime, oneShotEndTime, seed;
uniform float startAngle, startAngle2;

uniform float graphSampleSize;
uniform float graphNumSamples;
uniform sampler2D internalTex0;
uniform sampler2D internalTex1;
uniform sampler2D internalTex2;
uniform vec3 emitterScale;

float saturate(float x) {
    return clamp(x, 0.0, 1.0);
}

vec3 unpack3NFloats(float src) {
    float r = fract(src);
    float g = fract(src * 256.0);
    float b = fract(src * 65536.0);
    return vec3(r, g, b);
}

vec4 tex1Dlod_lerp(sampler2D tex, vec2 tc, out vec3 w) {
    vec4 a = texture2D(tex, tc);
    vec4 b = texture2D(tex, tc + graphSampleSize);
    float c = fract(tc.x * graphNumSamples);

    vec3 unpackedA = unpack3NFloats(a.w);
    vec3 unpackedB = unpack3NFloats(b.w);
    w = mix(unpackedA, unpackedB, c);

    return mix(a, b, c);
}

void main(void)
{
    if (gl_FragCoord.x > numParticles) discard;

    vec4 tex = texture2D(particleTexIN, vec2(vUv0.x, 0));

    float rndFactor = fract(sin(gl_FragCoord.x + 0.5 + seed));
    vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));

    float particleRate = rate + rateDiv * rndFactor;
    float particleLifetime = lifetime;
    float startSpawnTime = -particleRate * (gl_FragCoord.x - 0.5);
    float accumLife = max(totalTime + startSpawnTime + particleRate, 0.0);
    float life = mod(accumLife, particleLifetime + particleRate) - particleRate;

    if (life > 0.0) {
        life = clamp(life / particleLifetime, 0.0, 1.0);
        vec3 localVelocityDiv;
        vec3 velocityDiv;
        vec3 paramDiv;
        vec3 localVelocity =    tex1Dlod_lerp(internalTex0, vec2(life, 0), localVelocityDiv).xyz;
        vec3 velocity =         tex1Dlod_lerp(internalTex1, vec2(life, 0), velocityDiv).xyz;

        localVelocity +=        (localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor3;
        velocity +=             (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor3.zxy;

        if (gl_FragCoord.y < 1.0) {
            vec4 params =           tex1Dlod_lerp(internalTex2, vec2(life, 0), paramDiv);

            float rotSpeed = params.x;
            float rotSpeedDiv = paramDiv.y;

            rotSpeed +=             (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor3.y;

            tex.xyz += (emitterMatrix * localVelocity.xyz + velocity.xyz * emitterScale) * delta;
            tex.w += rotSpeed * delta;
        } else {
            // Only write velocity
            tex.xyz = (emitterMatrix * localVelocity.xyz + velocity.xyz * emitterScale);
            tex.w = 1.0;
        }
    }

